{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"SSO/AuthReverseProxy/","title":"Proposal for Reverse Proxy Authenticator","text":""},{"location":"SSO/AuthReverseProxy/#overview","title":"Overview","text":"<p>This document proposes a centralized solution for user identification and authorization using Single Sign On configured with OpenID PKCE. The reverse proxy's purpose is to resolve and manage all authentication logic and expose headers to services containing user information.</p>"},{"location":"SSO/AuthReverseProxy/#design","title":"Design","text":""},{"location":"SSO/AuthReverseProxy/#modes","title":"Modes","text":"<p>The reverse proxy would operate in 2 different modes:</p>"},{"location":"SSO/AuthReverseProxy/#passive-authorization","title":"Passive Authorization","text":"<p>The user is not required to be signed in when accessing resources. The reverse proxy will attach user data to headers if the user is authenticated; otherwise, the request is sent as it is (or optionally with a header like <code>X-User-auth: false</code>).</p> <p>Note: Passive mode is targeted for backend services that do not require authorization for every task (auth logic is handled by the service).</p>"},{"location":"SSO/AuthReverseProxy/#aggressive-authorization","title":"Aggressive Authorization","text":"<p>The user is required to be authenticated when accessing service resources.</p> <p>If a user is not authenticated, the proxy will redirect to the IdP for sign-in.</p> <p>Note: Aggressive mode is targeted for frontend and backend services in development.</p>"},{"location":"SSO/AuthReverseProxy/#configuration","title":"Configuration","text":"<p>The protected service will have to set the following data:</p> <ul> <li> <p><code>mode</code>: <code>passive</code>/<code>aggressive</code></p> </li> <li> <p><code>sign_in_path</code> - default: <code>/signIn</code></p> </li> <li> <p><code>callback_path</code> - default: <code>/callback</code></p> </li> <li> <p><code>post_sign_in_redirect_url</code> - e.g. <code>https://frontend/</code></p> <p>The path the user is redirected to after a successful sign-in</p> </li> <li> <p><code>idp_sign_out</code>: <code>false</code>/<code>true</code></p> <p>This configuration makes the proxy initiate IdP sign-out together with the service sign-out. This means the user is also signed out from the IdP, so for the next login attempt to any website using that IdP, they will have to sign in to the IdP again.</p> </li> <li> <p><code>post_sign_out_redirect_url</code> - e.g. <code>https://frontend/</code></p> <p>The path the user is redirected to after a successful sign-out</p> </li> <li> <p><code>notify_user_session</code>: <code>false</code>/<code>true</code></p> <p>This configuration makes the proxy call a predefined route with user data after a successful sign-in (the purpose is to inform the service that the user exists).</p> </li> <li> <p><code>notify_user_session_url</code> (required if <code>notify_user_session</code> is true) - e.g. <code>http://protected-service/api/user</code></p> <p>The path the proxy will call with user data after a successful sign-in</p> </li> <li> <p><code>attach_access_token</code>: <code>false</code>/<code>true</code></p> <p>This configuration makes the proxy attach the access token before forwarding the request.</p> </li> </ul>"},{"location":"SSO/AuthReverseProxy/#flow","title":"Flow","text":""},{"location":"SSO/AuthReverseProxy/#sign-in","title":"Sign In","text":"<p>For sign-in, the proxy will define 2 routes: <code>/${sign_in_path}</code> or <code>/signIn</code> and <code>/${callback_path}</code> or <code>/callback</code>. I will not go into detail about how these work; they are part of the OpenID specification.</p> <ul> <li> <p><code>/signIn</code>   This route will redirect the user to the IdP without any interaction with the protected service.</p> </li> <li> <p><code>/callback</code>   This route will redirect the user to a <code>post_sign_in_redirect_url</code> (most likely a frontend URL) and initialize the user session.</p> </li> </ul> <p>After that, if <code>notify_user_session</code> is true, it will call <code>notify_user_session_url</code> with the user data in the headers.</p>"},{"location":"SSO/AuthReverseProxy/#sign-out","title":"Sign Out","text":"<ul> <li><code>/signOut</code></li> </ul> <p>If <code>idp_sign_out</code> is true, this route will end the user session and then redirect to the IdP Sign Out page (which will redirect back to <code>post_sign_out_redirect_url</code>).</p> <p>If <code>idp_sign_out</code> is false, this route will end the user session and then redirect to the <code>post_sign_out_redirect_url</code>.</p>"},{"location":"SSO/AuthReverseProxy/#any-other-request","title":"Any other request","text":"<p>For any request except the ones provided above, the proxy will read the session data (if the user is authenticated) and attach ID token claims to the request headers like so:</p> <pre><code>// Headers:\n\"X-User-auth\": true,\n\"X-User-sub\": \"93j54f2l4...\",\n\"X-User-name\": \"Mihai\",\n\"X-User-...\": \"...\"\n</code></pre> <p>or</p> <pre><code>\"X-User-auth\": false\n</code></pre> <p>It will also attach the access token if <code>attach_access_token</code> is true and refresh it if expired (with the refresh token).</p> <pre><code>\"Bearer Token\": \"3m3vjk2b...\"\n</code></pre>"},{"location":"SSO/AuthReverseProxy/#proxy-design","title":"Proxy design","text":"<p>The proxy will keep sessions for every authenticated user. This means the browser will contain an opaque cookie <code>sessionID</code> that is tied to some data stored on the proxy.</p> <p>The proxy will store the tokens retrieved in the sign-in process (e.g. access, refresh, and ID token). It will keep this data in Redis (if the sessions turn out to be too many, we can offload tokens to a database like <code>Postgres</code> and cache sessions in <code>Redis</code>).</p> <p>Sessions will have a rolling expiration (most probably one week). After that, they will be invalidated.</p> <p>Rolling means that the expiration resets after every user interaction.</p>"},{"location":"SSO/AuthReverseProxy/#compatibility-with-traefik","title":"Compatibility with Traefik","text":"<p>Traefik supports the <code>forwardAuth</code> middleware, which offloads authentication to another server. Traefik makes a request to the authenticator server that contains the original request it received from the user.</p> <p> </p> <p>The auth server then makes a decision:</p> <ul> <li><code>2xx</code> - the request is OK and Traefik will forward it to the protected service (with added headers)</li> <li>otherwise, the request is rejected or redirected; the response will be the one provided by the auth server (the request does not reach the protected service)</li> </ul>"},{"location":"SSO/AuthReverseProxy/#trade-offs","title":"Trade-offs","text":""},{"location":"SSO/AuthReverseProxy/#benefits","title":"Benefits","text":"<ul> <li>Code simplicity: all authorization is handled by the proxy (no need for auth logic on the backend or frontend).</li> <li>Authentication changes are centralized and automatically apply to all applications.</li> <li>Consistent security across all services.</li> <li>Clear separation of concerns.</li> <li>Additional features can be added later, such as IP blocklists or rate limiting.</li> </ul>"},{"location":"SSO/AuthReverseProxy/#drawbacks","title":"Drawbacks","text":"<ul> <li>Introduces a single point of failure.</li> <li>Reduced flexibility for per-application authentication requirements.</li> <li>More difficult debugging and local development.</li> </ul>"},{"location":"SSO/AuthReverseProxy/#mitigations","title":"Mitigations","text":""},{"location":"SSO/AuthReverseProxy/#hybrid-mode","title":"Hybrid mode","text":"<p>Hybrid mode is a proposal to make the transition easier for backend services. In this mode, the proxy still performs the authorization steps, but instead of sending user data through request headers, it sends the ID token in the <code>Bearer</code> authorization header\u2014similar to how <code>react-oidc-context</code> operates. This means backend services would not need to change their existing authentication logic.</p>"},{"location":"SSO/AuthReverseProxy/#nodejs-library","title":"Node.js library","text":"<p>A significant drawback of the proxy is the difficulty of simulating the environment during local development. My proposed mitigation is a Node.js library that simulates the proxy in development and integrates with the proxy in production.</p>"},{"location":"SSO/AuthReverseProxy/#conclusion","title":"Conclusion","text":"<p>This is a large project, and this document cannot cover the entire workflow, but I hope it conveys the overall concept, intended use cases, advantages, and disadvantages.</p>"},{"location":"SSO/SSO.auth/","title":"OpenID Connect Authorization Design","text":""},{"location":"SSO/SSO.auth/#introduction","title":"Introduction","text":"<p>This document captures my research on authentication flows, common pitfalls, and security best practices related to user authorization.</p>"},{"location":"SSO/SSO.auth/#purpose","title":"Purpose","text":"<p>The goal of this document is not to prescribe a single \u201ccorrect\u201d authentication flow. Instead, it aims to highlight security considerations, potential vulnerabilities, and trade-offs involved in different design patterns.</p>"},{"location":"SSO/SSO.auth/#scope","title":"Scope","text":"<ul> <li>Basic concepts for user authorization</li> <li>OpenID Connect (OIDC) authorization flows</li> <li>XSS and CSRF risks and their implications in authorization</li> <li>Design trade-offs and security considerations</li> </ul>"},{"location":"SSO/SSO.auth/#terminology","title":"Terminology:","text":"<ul> <li><code>IdP</code> - stands for Identity Provider, meaning the server that handles authentication (e.g. Google SSO, LSAC SSO etc. )</li> <li><code>Client</code> - refering to the SSO Client, the application that uses the authentication provided by the <code>IdP</code></li> <li><code>User</code>/<code>End-User</code> - you</li> <li><code>SPA</code> - Single Page Application, a web app that loads a single web document and updates the body using javascript (ex: React, Angular, Vue)</li> </ul>"},{"location":"SSO/SSO.auth/#basic-concepts","title":"Basic concepts","text":"<p>If you are already familiar with JWT tokens you can skip this section.</p>"},{"location":"SSO/SSO.auth/#how-jwt-tokens-work","title":"How JWT Tokens Work","text":"<p>JWT (JSON Web Token) is a type of token commonly used for authentication and authorization. It not only conveys information but also ensures the integrity of that information through signatures. A JWT is composed of three parts:</p>"},{"location":"SSO/SSO.auth/#1-header","title":"1. Header","text":"<p>The header specifies the cryptographic algorithm used to sign the token and other metadata.</p> <p>Example:</p> <pre><code>{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n</code></pre> <p>Important: Except for debugging purposes, a JWT with <code>\"alg\": \"none\"</code> must NEVER be accepted. Although defined in JWT specification, it's extremely unsecure.</p>"},{"location":"SSO/SSO.auth/#2-payload","title":"2. Payload","text":"<p>The payload contains claims\u2014information about the user or session.</p> <p>Example:</p> <pre><code>{\n  \"sub\": \"1234567890\", // user id\n  \"name\": \"John Doe\",\n  \"admin\": true,\n  \"iat\": 1516239022 // issued at &lt;timestamp&gt;\n}\n</code></pre>"},{"location":"SSO/SSO.auth/#3-signature","title":"3. Signature","text":"<p>The signature ensures that the token has not been tampered with, the process of signing requires encrypting the header and payload to attest their authenticity. A signature must respect two rules:</p> <ul> <li>the signature can be generated ONLY by the IdP</li> <li>once generated, the signature must be verifiable by the IdP that issued it and optionally by third parties</li> </ul> <p>In SSO scenarios, asymmetric signing is typically used. The Identity Provider (IdP) signs the JWT with its private key, and anyone with the public key can verify it:</p> <pre><code>// Creating a signature\nsignature = Encrypt(private_key, header + '.' + payload)\n\n// Verifying a signature\nheader + '.' + payload === Decrypt(public_key, signature)\n</code></pre> <p>Alternatively, symmetric signing uses a shared secret known only to the IdP:</p> <pre><code>// Creating a signature\nsignature = Hash(secret, header + '.' + payload)\n\n// Verifying a signature\nHash(secret, header + '.' + payload) === signature\n</code></pre> <p>Note: JWT tokens generated with symmetric signing cannot be verified by anyone except the IdP</p> <p>Important: If the secret is compromised, an attacker could generate valid JWTs and impersonate any user. This is why private key management and secure signing practices are critical.</p>"},{"location":"SSO/SSO.auth/#the-purpose-of-access-refresh-and-id-tokens","title":"The Purpose of Access, Refresh, and ID Tokens","text":"<p>Access, Refresh, and ID tokens are all commonly implemented as JWTs, but each serves a distinct purpose in the authentication and authorization process:</p> <p>1. ID Token</p> <ul> <li>Contains information about the authenticated user, such as user ID, name, and email.</li> <li>Used by the client to identify the end-user and establish a session.</li> </ul> <p>Example:</p> <pre><code>{\n  \"sub\": \"1234567890\", // user id\n  \"name\": \"John Doe\",\n  \"email\": \"john.doe@example.com\",\n  \"iat\": 1516239022, // issued at\n  \"exp\": 1516242622 // expiration\n}\n</code></pre> <p>2. Access Token</p> <ul> <li>Short-lived token used to authorize API requests on behalf of the user.</li> <li>Typically sent in the <code>Authorization</code> header as a bearer token.</li> </ul> <p>3. Refresh Token</p> <ul> <li>Long-lived token used to obtain new access tokens when they expire.</li> <li>Can also be used to refresh itself in some flows, depending on the IdP.</li> <li>Must be stored securely (server-side or in httpOnly cookies) because it can be used to gain new access tokens indefinitely.</li> </ul>"},{"location":"SSO/SSO.auth/#authorization-flows-in-oidc-openid-connect","title":"Authorization Flows in OIDC / OpenID Connect","text":""},{"location":"SSO/SSO.auth/#implicit-authorization-flow","title":"Implicit Authorization Flow","text":"<p>The Implicit Flow was originally designed for SPAs where a client secret could not be safely stored. It is now considered deprecated and unsecure.</p> <p> </p>"},{"location":"SSO/SSO.auth/#steps","title":"Steps","text":"<ol> <li>User initiates sign in, makes a request to the client - ex: <code>https://example.ro/signIn</code></li> <li>Client redirects user to the Identity Provider (IdP) - ex: <code>https://sso.ro/signIn</code></li> <li>User logs in with credentials.</li> <li>After successful authentication, the IdP redirects the user back to the client with access and ID tokens directly in the redirect (usually in the URL) - ex: <code>https://example.ro?accessToken=...&amp;idToken=...</code></li> </ol>"},{"location":"SSO/SSO.auth/#problems","title":"Problems","text":"<ul> <li>Tokens can appear in browser history or logs.</li> <li>SPAs expose tokens to JavaScript, making them vulnerable to XSS.</li> <li>No server-side token exchange step.</li> </ul>"},{"location":"SSO/SSO.auth/#authorization-code-flow","title":"Authorization Code Flow","text":"<p>The Authorization Code Flow improves security by returning only an authorization code to the client. The client must then exchange it for tokens.</p> <p> </p>"},{"location":"SSO/SSO.auth/#steps_1","title":"Steps","text":"<p>1. User initiates sign-in and makes a request to the client \u2014 e.g. <code>https://example.ro/signIn</code></p> <ul> <li>The client generates a state value (random string) to protect against CSRF attacks.</li> <li>The client generates a nonce value to bind the issued ID token to the request and prevent replay attacks.</li> </ul> <p>2. Client redirects the user to the Identity Provider (IdP) \u2014 e.g. <code>https://sso.ro/signIn?state=STATE&amp;nonce=NONCE</code></p> <p>3. User logs in with credentials.</p> <p>4. The IdP redirects the user back to the client with an authorization code \u2014 e.g.    <code>https://example.ro?authCode=...&amp;iss=...&amp;state=STATE</code></p> <ul> <li>The client must verify that the returned <code>state</code> value matches the one it generated.</li> </ul> <p>5. The client then exchanges the code for tokens (<code>access token</code>, <code>id token</code>, sometimes <code>refresh token</code>).    The IdP provides a route for this purpose \u2014 e.g. <code>https://sso.ro/tokens</code>.</p> <pre><code>body: {\n  \"code\": AUTH_CODE, // from IdP callback\n  ...\n}\n</code></pre> <p>Note: Depending on the type of application, these tokens can be used directly or the client can issue new tokens or sessions.</p>"},{"location":"SSO/SSO.auth/#problems_1","title":"Problems","text":"<ul> <li>Without PKCE, the code can be intercepted and misused.</li> <li>Storing tokens directly in a SPA still carries the same exposure risks as the implicit flow.</li> </ul>"},{"location":"SSO/SSO.auth/#authorization-code-flow-with-pkce","title":"Authorization Code Flow with PKCE","text":"<p>The Authorization Code Flow with PKCE adds protection against code interception. PKCE (Proof Key for Code Exchange) is an algorithm that ensures continuity between the initial redirect and the code-exchange step by leveraging a random string and its hash.</p> <p> </p>"},{"location":"SSO/SSO.auth/#steps_2","title":"Steps","text":"<p>1. User initiates sign-in \u2014 e.g. <code>https://example.ro/signIn</code></p> <ul> <li>The client generates a cryptographically random code verifier (random string).</li> <li>The client derives a code challenge from the verifier (typically a SHA-256 hash).</li> <li>The client generates a state value for CSRF protection.</li> <li>The client generates a nonce value for ID token replay protection.</li> <li>The client sends the code challenge, state, and nonce along with the authorization request.</li> </ul> <p>2. Client redirects the user to the Identity Provider (IdP) with the code challenge \u2014 e.g. <code>https://sso.ro/signIn?code_challenge=...&amp;state=STATE&amp;nonce=NONCE</code></p> <p>3. After successful authentication, the IdP redirects the user back with the authorization code \u2014 e.g. <code>https://example.ro?authCode=...&amp;iss=...&amp;state=STATE</code></p> <ul> <li>The client must verify the <code>state</code> value before exchanging the code.</li> </ul> <p>4. The client exchanges the authorization code together with the original code verifier for access and identity tokens \u2014 e.g. <code>https://sso.ro/token</code></p> <pre><code>body: {\n  \"code\": AUTH_CODE, // auth code from callback\n  \"code_verifier\": CODE_VERIFIER,\n  \"client_id\": CLIENT_ID\n  ... // other data included such as client secret, redirect URI, etc.\n}\n</code></pre> <p>5. The IdP checks that the code verifier corresponds to the previously sent code challenge, and if valid, issues tokens.</p> <ul> <li>The client checks the <code>nonce</code> inside the ID token to ensure it matches the originally generated nonce.</li> </ul> <p>Note: The IdP does not send the code challenge back to the client. The client must remember the verifier (as well as the state and nonce) locally.</p>"},{"location":"SSO/SSO.auth/#cross-site-scripting-xss","title":"Cross-Site Scripting (XSS)","text":"<p>To understand why storing tokens in a Single Page Application (SPA) is discouraged, it\u2019s important to first understand Cross-Site Scripting (XSS). XSS occurs when an attacker injects malicious JavaScript into a website, which then executes in another user\u2019s browser.</p> <p>This vulnerability has two key components:</p> <p>1. The server accepts malicious input</p> <p>This is a broad category: malicious input may include raw HTML, SVG files, or anything that can contain executable JavaScript. The critical factor is that this input can later be accessed or rendered by other users.</p> <p>2. The server returns that malicious input to other users</p> <p>When the injected content is delivered to another user\u2019s browser and executed, the attack is successful. At that point, the attacker can access user credentials, tokens, session data, or perform arbitrary actions on behalf of the user.</p>"},{"location":"SSO/SSO.auth/#mitigations","title":"Mitigations","text":"<ul> <li>Sanitize and encode user input</li> </ul> <p>Frameworks like React automatically HTML-encode any content placed in <code>{}</code> expressions, preventing raw HTML from rendering unless explicitly allowed via <code>dangerouslySetInnerHTML</code>.</p> <ul> <li>Avoid rendering powerful HTML elements using untrusted data</li> </ul> <p>Elements such as:</p> <pre><code>  &lt;iframe&gt;&lt;/iframe&gt;\n  &lt;embed&gt;&lt;/embed&gt;\n  &lt;script&gt;&lt;/script&gt;\n</code></pre> <p>should never be populated from user-controlled sources, as they allow direct execution of arbitrary content.</p> <ul> <li>Enforce strict formats on user-uploaded files</li> </ul> <p>For file uploads\u2014whether stored in S3 or on local disk\u2014restrict the allowed file types and validate the actual file contents (MIME sniffing), not just the extension. Do not permit arbitrary formats such as SVGs or HTML files unless absolutely required.</p> <ul> <li>Use Content Security Policy (CSP)</li> </ul> <p>A strong CSP can significantly reduce the impact of XSS by blocking inline scripts and limiting where scripts can load from.</p> <ul> <li>Avoid dangerous APIs</li> </ul> <p>Functions such as <code>innerHTML</code>, <code>document.write</code>, and <code>eval</code> dramatically increase XSS risk and should not be used with untrusted data.</p>"},{"location":"SSO/SSO.auth/#spa-token-storage","title":"SPA Token Storage","text":"<p>For applications that require strong security guarantees, relying on SPA token storage is discouraged. In SPAs, tokens cannot be stored in httpOnly cookies\u2014meaning they must be stored in JavaScript-accessible storage (localStorage/sessionStorage).</p>"},{"location":"SSO/SSO.auth/#vulnerabilities","title":"Vulnerabilities","text":"<ul> <li>XSS can steal tokens.</li> <li>Any malicious script running in the browser can access the stored tokens.</li> </ul>"},{"location":"SSO/SSO.auth/#react-spa-flow","title":"React SPA Flow","text":"<p>Libraries like react-oidc-context, built on top of oidc-client-ts, provide OIDC support specifically for SPA React applications. They use Authorization Code Flow with PKCE but store tokens in <code>localStorage</code> or <code>sessionStorage</code>, making them inherently vulnerable to token theft if an XSS occurs.</p>"},{"location":"SSO/SSO.auth/#backend-authorization-code-flow-with-pkce","title":"Backend Authorization Code Flow with PKCE","text":"<p>Backend authorization requires shifting the business logic for authentication from the client to the server. This allows credentials to be stored in httpOnly cookies, and ensures that sensitive authorization steps are executed entirely on the backend, hidden from both the browser and the end user. To implement this, two server endpoints are usually added:</p> <ul> <li><code>/auth/login</code> -&gt; this endpoint generates A PKCE code challange and stores the verifier on the server, then it redirects the user to the IdP with the code challange</li> <li><code>/auth/callback</code> -&gt; this endpoint is meant for IdP redirection, once the end-user signs in, the IdP redirects to this route with the authorization code that is later exchanged for tokens together with the code verifier</li> </ul> <p>Using the Authorization Code Flow with PKCE on the backend reduces the attack surface significantly. The main remaining question is how tokens should be stored once the backend obtains them. Here are two options for authorization cookie storage:</p>"},{"location":"SSO/SSO.auth/#option-1-store-idp-issued-access-and-id-tokens-on-the-frontend-as-httponly-cookies","title":"Option 1: Store IdP issued Access and ID Tokens on the Frontend as httpOnly Cookies","text":"<p>Storing tokens in httpOnly cookies is technically secure from a browser-accessibility standpoint. However, this pattern is generally avoided due to the principles of:</p> <ul> <li>Isolation \u2013 The frontend should not automatically gain access to all user identity and authorization information.</li> <li>Least Privilege \u2013 The user should only receive the minimum data needed to function.</li> </ul> <p>Instead of placing access/ID/refresh tokens directly in cookies, it is considered best practice to issue a session identifier. This allows the backend to control exactly what information is delivered to the frontend and avoids exposing raw tokens to the browser at all. Moreover, IdP's can be generous with cookie expiration, so issuing a session cookie enables the applications to have more control on cookie expiration and session management.</p>"},{"location":"SSO/SSO.auth/#option-2-store-idp-issued-access-and-id-tokens-on-the-backend-use-session-cookie-for-communication-with-the-frontend-recommended","title":"Option 2: Store IdP issued Access and ID Tokens on the Backend, use Session Cookie for communication with the Frontend (Recommended)","text":"<p>A session cookie is an httpOnly, typically secure, cookie that stores only a random, opaque identifier. This identifier maps to server-side session data that the backend controls.</p> <p> </p>"},{"location":"SSO/SSO.auth/#flow","title":"Flow","text":"<p>Alongside the standard PKCE authentication flow:</p> <p>1. User initiates sign in, makes a request to the client - ex: <code>https://example.ro/signIn</code></p> <p>2. Before redirecting the user to the IdP, the client creates a session and stores the generated code verifier inside it.</p> <p>3. The user signs in with credentials on the IdP.</p> <p>4. After the callback, the backend uses:</p> <ul> <li>the authorization code from the redirect, and</li> <li>the code verifier retrieved from the session to exchange for tokens.</li> </ul> <p>5. The backend stores relevant user information in the session (derived from its database or from ID token claims, depending on architecture).</p> <p>6. The frontend receives only the session cookie.</p> <p>7. Any interaction between the user and backend is done through this session cookie.</p> <p>Note: The Access Token retrieved from the IdP can be stored on the backend and used to perform API requests on behalf of the user.</p>"},{"location":"SSO/SSO.auth/#sudo-mode","title":"Sudo Mode","text":"<p>Many providers (e.g., GitHub, Google, AWS) implement sudo mode, a mechanism that enforces authentication freshness for sensitive operations.</p> <p>Key Behaviors</p> <ul> <li>High-risk actions (such as deletions, privilege changes, or configuration updates) require a recently authenticated session.</li> <li>If the current session is older than the defined freshness window (typically several hours), the user must reauthenticate through SSO before the action is allowed.</li> <li>Normal, low-risk actions continue to function without requiring reauthentication.</li> </ul>"},{"location":"SSO/SSO.auth/#cross-site-request-forgery-csrf","title":"Cross-Site Request Forgery (CSRF)","text":"<p>Now that the application is mostly secure, we must consider another subtle vulnerability introduced when switching to cookie-based authentication. Previously, when tokens were stored in <code>localStorage</code> or <code>sessionStorage</code>, they had to be manually added to the <code>Authorization</code> header for each request. This implicitly protected against CSRF, because the browser could not automatically attach those tokens.</p> <p>CSRF occurs when a user, often through social engineering, is tricked into making unintended requests to a site where they are already authenticated. For example, a malicious website could include:</p> <pre><code>&lt;form action=\"https://site.i.am.logged.in.to/pay_100_dolars\" method=\"POST\"&gt;\n  &lt;!-- auto-submitted via JavaScript --&gt;\n&lt;/form&gt;\n</code></pre> <p>If the target site uses cookies for authentication, and these cookies are sent automatically (<code>SameSite=None</code>), the browser will attach them to the request, even though the user never intended to perform the action.</p>"},{"location":"SSO/SSO.auth/#mitigations_1","title":"Mitigations","text":""},{"location":"SSO/SSO.auth/#set-cookies-with-samesitelax-or-samesitestrict","title":"Set cookies with <code>SameSite=Lax</code> or <code>SameSite=Strict</code>","text":"<p>These settings prevent cookies from being sent on cross-site requests. <code>Lax</code> blocks most cross-site POST requests, while <code>Strict</code> blocks all cross-site navigations.</p> <p>This mitigation is often enough for CSRF protection, unless the server must use <code>SameSite=None</code> cookies or absolutely needs confirmation that the user intended the request.</p>"},{"location":"SSO/SSO.auth/#use-csrf-tokens","title":"Use CSRF tokens","text":"<p>CSRF tokens are unpredictable values generated by the server and included in forms or API requests. Since they must be added manually via JavaScript (or injected into the page), the browser cannot include them automatically. This ensures that a cross-site request made by an attacker will be missing the required token.</p> <p>This mirrors how SPA authentication used to work: access tokens stored in browser storage had to be manually attached as headers, making them functionally similar to CSRF tokens. That is why traditional SPA token-based workflows generally did not require separate CSRF protection, the token itself served that purpose.</p>"},{"location":"SSO/SSO.auth/#csrf-tokens","title":"CSRF Tokens","text":"<p>This topic can quickly become a rabbit-hole, so here is a concise overview of the two common approaches for implementing CSRF protection:</p> <p>1. Session-based tokens (stateful)</p> <p>The server stores a CSRF token in the user\u2019s session. For any non-<code>GET</code> request (<code>POST</code>, <code>PUT</code>, <code>DELETE</code>), the frontend must include the token, usually in a header or hidden form field. The server validates that the provided token matches the one stored in the session.</p> <p>2. Double-cookie tokens (stateless)</p> <p>This method avoids storing tokens on the server. Instead, the backend issues a CSRF token to the frontend as a cookie. When the user makes an API request, the token is sent twice:</p> <ul> <li>once automatically by the browser via the cookie</li> <li>once manually in a request header set by JavaScript</li> </ul> <p>The server compares the two values. If they match, the request is allowed.</p> <p>Note: The token must be signed by the server (HMAC) to ensure it was issued by the backend and not forged by an attacker.</p> <p>Important: <code>GET</code> requests should never modify server-side state. A CSRF attack allows an attacker to trigger a request from the victim\u2019s browser, but not to read the response (because of same-origin policies).</p> <p>Because <code>GET</code> requests are meant to be safe, they typically do not require CSRF protection\u2014since, under proper API design, they should only retrieve data and never cause changes.</p>"},{"location":"SSO/SSO.auth/#tradeoffs","title":"Tradeoffs","text":"<p>Adopting backend-managed PKCE authorization increases security but introduces new considerations.</p>"},{"location":"SSO/SSO.auth/#complexity","title":"Complexity","text":"<ul> <li>Each backend client must manage server-side sessions.</li> <li>Each backend must implement the Authorization Code Flow with PKCE (including code-verifier persistence, code exchange, token handling, refresh logic, etc.).</li> <li>Session lifecycle management (expiration, rotation, revocation) becomes part of the backend.</li> <li>CSRF protection</li> </ul>"},{"location":"SSO/SSO.auth/#resource-usage","title":"Resource Usage","text":"<ul> <li>Compute:   The server performs the token exchange and additional authorization logic that would otherwise run in the client.</li> <li>Storage / Memory:   Session data must be persisted for all authenticated users.   This is commonly managed through stores such as Redis.</li> </ul>"},{"location":"SSO/SSO.auth/#conclusion","title":"Conclusion","text":"<p>Implementing secure authorization flows comes with many pitfalls. Strengthening security in one area can inadvertently expose weaknesses elsewhere, and in general, higher security often comes with increased complexity and resource requirements. </p> <p>While no approach is perfect, this document highlights key best practices and trade-offs to consider when designing SSO authorization.</p>"}]}